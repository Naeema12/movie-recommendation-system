# -*- coding: utf-8 -*-
"""movie-recommendation-system

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15P7dnHUtF3YKAL3_X3eWt4OEj9m2q4Sp
"""

import pandas as pd

ratings = pd.read_csv("ratings.csv")
movies = pd.read_csv("movies.csv")

ratings.head(), movies.head()

ratings.info()
movies.info()

n_users = ratings["userId"].nunique()
n_movies = ratings["movieId"].nunique()
n_ratings = len(ratings)

n_users, n_movies, n_ratings

"""Rating Distribution (CRITICAL FOR RECOMMENDERS)"""

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(6,4))
sns.countplot(data=ratings, x="rating")
plt.title("Rating Distribution")
plt.xlabel("Rating")
plt.ylabel("Count")
plt.show()

top_movies = (
    ratings.groupby("movieId")["rating"]
    .count()
    .sort_values(ascending=False)
    .head(10)
)

top_movies

"""Movies With Most Ratings (POPULARITY INSIGHT)"""

top_movies = (
    ratings.groupby("movieId")["rating"]
    .count()
    .sort_values(ascending=False)
    .head(10)
)

top_movies

top_movies = top_movies.reset_index().merge(movies, on="movieId")
top_movies[["title", "rating"]]

"""Compute Average Rating & Rating Count"""

movie_stats = (
    ratings.groupby("movieId")
    .agg(
        avg_rating=("rating", "mean"),
        rating_count=("rating", "count")
    )
    .reset_index()
)

movie_stats.head()

"""Filtering Movies With Enough Ratings"""

popular_movies = movie_stats[movie_stats["rating_count"] >= 50]
popular_movies = popular_movies.merge(movies, on="movieId")

popular_movies.sort_values(
    by="avg_rating",
    ascending=False
).head(10)[["title", "avg_rating", "rating_count"]]

"""Wraping Baseline Recommender Into a Function."""

def recommend_popular(n=10, min_ratings=50):
    recs = (
        movie_stats[movie_stats["rating_count"] >= min_ratings]
        .merge(movies, on="movieId")
        .sort_values(by="avg_rating", ascending=False)
        .head(n)
    )
    return recs[["title", "avg_rating", "rating_count"]]

recommend_popular(10)

"""Creating the User–Item Matrix (FOUNDATION)"""

user_item_matrix = ratings.pivot_table(
    index="userId",
    columns="movieId",
    values="rating"
)

user_item_matrix.head()

"""Reducing the noise

We remove movies with very few ratings.
"""

min_ratings = 50

movie_rating_counts = ratings.groupby("movieId")["rating"].count()
popular_movie_ids = movie_rating_counts[movie_rating_counts >= min_ratings].index

user_item_matrix_filtered = user_item_matrix[popular_movie_ids]
user_item_matrix_filtered.shape

"""Transpose for Item-Based Filtering

We want movie–movie similarity, not user–user.
"""

movie_user_matrix = user_item_matrix_filtered.T
movie_user_matrix.head()

"""Compute Cosine Similarity"""

from sklearn.metrics.pairwise import cosine_similarity

movie_similarity = cosine_similarity(movie_user_matrix.fillna(0))

"""I used cosine similarity to measure similarity between movies based on user ratings"""

movie_similarity_df = pd.DataFrame(
    movie_similarity,
    index=movie_user_matrix.index,
    columns=movie_user_matrix.index
)

movie_similarity_df.head()

"""Building the Recommendation Function"""

def recommend_similar_movies(movie_title, n=10):
    # Get movieId from title
    movie_id = movies[movies["title"] == movie_title]["movieId"].values

    if len(movie_id) == 0:
        return "Movie not found"

    movie_id = movie_id[0]

    # Get similarity scores
    sim_scores = movie_similarity_df[movie_id]

    # Sort and remove the movie itself
    sim_scores = sim_scores.sort_values(ascending=False)[1:n+1]

    # Get movie titles
    recommended_movies = movies[movies["movieId"].isin(sim_scores.index)]

    return recommended_movies[["title", "genres"]]

"""I validated recommendations qualitatively by checking if similar movies made intuitive sense."""

recommend_similar_movies("Toy Story (1995)", 10)

"""Visualizing Similarity"""

def get_similar_movies_with_scores(movie_title, n=10):
    movie_id = movies[movies["title"] == movie_title]["movieId"].values

    if len(movie_id) == 0:
        return None

    movie_id = movie_id[0]

    sim_scores = movie_similarity_df[movie_id].sort_values(ascending=False)[1:n+1]

    result = (
        sim_scores.reset_index()
        .merge(movies, on="movieId")
        .rename(columns={movie_id: "similarity"})
    )

    result.columns = ["movieId", "similarity", "title", "genres"]
    return result

similar_movies = get_similar_movies_with_scores("Toy Story (1995)", 10)

plt.figure(figsize=(8,5))
sns.barplot(
    data=similar_movies,
    x="similarity",
    y="title"
)
plt.title("Top Similar Movies to Toy Story (1995)")
plt.xlabel("Cosine Similarity")
plt.ylabel("")
plt.show()

"""Train / Test Split"""

from sklearn.model_selection import train_test_split

# Sort by time (important for realism)
ratings_sorted = ratings.sort_values("timestamp")

# Take last rating of each user as test
test = ratings_sorted.groupby("userId").tail(1)
train = ratings_sorted.drop(test.index)

train.shape, test.shape

train_matrix = train.pivot_table(
    index="userId",
    columns="movieId",
    values="rating"
)

# Filter to popular movies (same threshold as before)
train_matrix = train_matrix[popular_movie_ids]

movie_user_train = train_matrix.T

movie_similarity_train = cosine_similarity(
    movie_user_train.fillna(0)
)

movie_similarity_train_df = pd.DataFrame(
    movie_similarity_train,
    index=movie_user_train.index,
    columns=movie_user_train.index
)

def recommend_similar_movies_by_id(movie_id, n=10):
    if movie_id not in movie_similarity_train_df.columns:
        return []

    sim_scores = (
        movie_similarity_train_df[movie_id]
        .sort_values(ascending=False)
        .index[1:n+1]
    )
    return list(sim_scores)

def precision_at_k(test_df, k=10):
    hits = 0
    total = 0

    for _, row in test_df.iterrows():
        user = row["userId"]
        true_movie = row["movieId"]

        # Movies the user rated in training
        user_movies = train[train["userId"] == user]["movieId"].values

        if len(user_movies) == 0:
            continue

        # Use the last movie the user rated in training as seed
        seed_movie = user_movies[-1]

        recs = recommend_similar_movies_by_id(seed_movie, k)

        if true_movie in recs:
            hits += 1

        total += 1

    return hits / total

precision_10 = precision_at_k(test, k=10)
precision_10